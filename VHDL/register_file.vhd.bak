library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.package.all;

entity register_file is	
	port(
		clk: in std_logic;
		rst: in std_logic;--reset attivo alto
		
		RegWrite: in std_logic; -- write enable
		read_en: in std_logic; --read enable
		read_register_1: in std_logic_vector(length_in_RF-1 downto 0);
		read_register_2: in std_logic_vector(length_in_RF-1 downto 0);
		write_register: in std_logic_vector(length_in_RF-1 downto 0);
		write_data: in std_logic_vector(data_parallelism-1 downto 0);
		
		read_data_1: out std_logic_vector(data_parallelism-1 downto 0);
		read_data_2: out std_logic_vector(data_parallelism-1 downto 0);
		
	);
end register_file;

architecture behavioural of register_file is
	type regs is array ( 0 to number_regs-1) of signed(data_parallelism -1 downto 0);
	signal registers: regs; -- crea un signal (array) di appoggio per fare tutte le operazioni
	
	begin
	
	reset_proc: process(rst)
	begin
		if(rst='1') then 
					for i in 0 to number_regs-1 loop
						registers(i)<=(others=>'0');
						read_data_1<=(others=>'0');
						read_data_2<=(others=>'0');
					end loop;
		end if;
		
	end process reset_proc;
	
	
	read_proc: process (read_register1, read_register_2, read_en)
	begin
		if (read_en = '1') then
			
			read_data_1<=registers(to_integer(unsigned(read_register_1)));
			read_data_2<=registers(to_integer(unsigned(read_register_2)));
			
		else
		
		    read_data_1<=(others=>'0');
			read_data_2<=(others=>'0');
			
		 end if;
		 
	end process read_proc;

	write_proc: process(clk)
	begin
		if(clk'event and clk = '1') then
									
				if (RegWrite = '1') then
				
					registers(to_integer(unsigned(write_register))) <= write_data;
							
				end if;

		end if;
		
	end process write_proc;
	
end behavioural;
				
				
				
		
		
		
		
	
		